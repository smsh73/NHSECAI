# 워크플로우 노드 순서 및 세션 데이터 정합성 분석

**작성일**: 2025-01-28  
**분석 대상**: 워크플로우 실행 엔진의 노드 실행 순서 결정 및 세션 데이터 저장 로직

---

## 1. 현재 구현 상태

### 1.1 노드 실행 순서 결정 로직

**구현 방식**: `sortNodesTopologically` 함수 (Kahn's algorithm 사용)

```typescript
private sortNodesTopologically(nodes: WorkflowNode[], edges: Array<{ source: string; target: string }>): WorkflowNode[]
```

**핵심 로직**:
1. edges를 기반으로 인접 리스트(adjacency list)와 in-degree 계산
2. in-degree가 0인 노드들부터 시작 (의존성이 없는 노드)
3. 위상 정렬(Topological Sort)을 통해 실행 순서 결정
4. **노드 생성 순서는 전혀 고려하지 않음**

**결론**: ✅ **노드 생성 순서와 실행 순서는 완전히 무관합니다.**  
edges의 연결 관계만으로 실행 순서가 결정됩니다.

### 1.2 세션 데이터 저장/조회 로직

**저장**: `saveNodeOutputToSession(sessionId, nodeId, output)`
- 데이터 키: `${nodeId}_output`
- 테이블: `workflow_session_data`
- 인덱스: `(sessionId, dataKey)` 조합으로 unique index

**조회**: `getNodeOutputFromSession(sessionId, nodeId)`
- 데이터 키: `${nodeId}_output`
- 세션 ID와 노드 ID 기반으로 조회

**이전 노드 출력 조회**: `getPreviousNodeOutputs(sessionId, nodeId, edges)`
- edges를 기반으로 이전 노드들을 찾음
- 각 이전 노드의 출력을 세션 테이블에서 조회

**결론**: ✅ **세션 데이터 저장/조회는 `nodeId`와 `sessionId` 기반이므로 정합성 문제 없습니다.**  
노드 생성 순서와 무관하게 올바르게 동작합니다.

### 1.3 데이터 전달 로직

**자동 전달**: `prepareNodeInput` 함수
- `inputMapping`이 없으면 edges를 통해 이전 노드들을 자동으로 찾음
- 이전 노드들의 출력을 세션 테이블에서 조회하여 입력 데이터로 사용

**수동 매핑**: `inputMapping` 설정 시
- `$nodeId` 형태로 다른 노드의 출력을 참조 가능
- 세션 테이블에서 해당 노드의 출력을 조회

**결론**: ✅ **데이터 전달 로직은 edges 기반이므로 노드 생성 순서와 무관합니다.**

---

## 2. 잠재적 문제점

### 2.1 `WorkflowNode` 인터페이스의 `order` 필드

**현재 상태**:
```typescript
export interface WorkflowNode {
  id: string;
  name: string;
  type: 'prompt' | 'api_call' | ...;
  configuration: any;
  order: number;  // ⚠️ 정의되어 있지만 사용되지 않음
}
```

**문제점**:
- `order` 필드가 인터페이스에 정의되어 있지만 실제로 사용되지 않음
- `sortNodesTopologically` 함수는 `order` 필드를 전혀 참조하지 않음
- 사용자가 혼란스러워할 수 있음

**권장 사항**:
1. `order` 필드를 인터페이스에서 제거 (또는 optional로 변경)
2. 또는 주석으로 "deprecated" 또는 "not used" 명시

### 2.2 위상 정렬 후 남은 노드 처리

**현재 로직** (1175-1181 라인):
```typescript
// If there are cycles or nodes not in edges, add remaining nodes
const sortedIds = new Set(sorted.map(n => n.id));
nodes.forEach(node => {
  if (!sortedIds.has(node.id)) {
    sorted.push(node);
  }
});
```

**잠재적 문제**:
- edges에 연결되지 않은 노드들도 정렬 결과에 포함됨
- 이 노드들의 실행 순서는 `nodes` 배열의 순서에 따라 결정됨 (노드 생성 순서에 영향받을 수 있음)

**권장 사항**:
- edges에 연결되지 않은 노드들은 경고 메시지를 로그에 남기거나
- 사용자에게 명확히 알려주는 것이 좋음

---

## 3. 정합성 검증

### 3.1 노드 생성 순서와 실행 순서

**시나리오 1**: 노드를 뒤에서부터 생성 (Python → API → Prompt)
```
1. Python 노드 생성 (nodeId: "node-3")
2. API 노드 생성 (nodeId: "node-2")
3. Prompt 노드 생성 (nodeId: "node-1")
4. 연결선 생성: Prompt → API → Python
```

**실행 순서**: Prompt → API → Python (edges 기반 위상 정렬)  
**결과**: ✅ 노드 생성 순서와 무관하게 올바른 순서로 실행됨

**시나리오 2**: 노드를 중간에서부터 생성 (API → Prompt → Python)
```
1. API 노드 생성 (nodeId: "node-2")
2. Prompt 노드 생성 (nodeId: "node-1")
3. Python 노드 생성 (nodeId: "node-3")
4. 연결선 생성: Prompt → API → Python
```

**실행 순서**: Prompt → API → Python (edges 기반 위상 정렬)  
**결과**: ✅ 노드 생성 순서와 무관하게 올바른 순서로 실행됨

### 3.2 세션 데이터 저장/조회

**시나리오**: 노드가 다른 순서로 실행되더라도
```
1. Prompt 노드 실행 → 출력 저장: `workflow_session_data.dataKey = "node-1_output"`
2. API 노드 실행 → 이전 노드 출력 조회: `getNodeOutputFromSession(sessionId, "node-1")`
3. Python 노드 실행 → 이전 노드 출력 조회: `getNodeOutputFromSession(sessionId, "node-2")`
```

**결과**: ✅ 세션 데이터는 `nodeId`와 `sessionId` 기반으로 저장/조회되므로 정합성 문제 없음

---

## 4. 결론

### ✅ 정합성 문제 없음

1. **노드 실행 순서**: edges 기반 위상 정렬로 결정되므로 노드 생성 순서와 무관
2. **세션 데이터 저장/조회**: `nodeId`와 `sessionId` 기반이므로 정합성 문제 없음
3. **데이터 전달**: edges 기반으로 이전 노드를 찾아 세션 테이블에서 조회하므로 정확함

### ⚠️ 개선 권장사항

1. **`order` 필드 제거 또는 명시**: 인터페이스에서 사용되지 않는 `order` 필드를 제거하거나 주석으로 명시
2. **연결되지 않은 노드 처리**: edges에 연결되지 않은 노드들에 대한 경고 또는 알림 추가
3. **문서화**: 노드 생성 순서가 실행 순서와 무관하다는 것을 명확히 문서화

---

## 5. 권장 수정사항

### 5.1 `WorkflowNode` 인터페이스 수정

```typescript
export interface WorkflowNode {
  id: string;
  name: string;
  type: 'prompt' | 'api_call' | ...;
  configuration: any;
  // order 필드 제거 (또는 optional로 변경)
  // order?: number; // Deprecated: 실행 순서는 edges 기반 위상 정렬로 결정됨
}
```

### 5.2 위상 정렬 후 남은 노드 처리 개선

```typescript
// 연결되지 않은 노드들에 대한 경고 로그 추가
const isolatedNodes = nodes.filter(node => !sortedIds.has(node.id));
if (isolatedNodes.length > 0) {
  detailedLogger.warn({
    service: 'WorkflowExecutionEngine',
    task: 'sortNodesTopologically',
    message: `연결되지 않은 노드 발견: ${isolatedNodes.map(n => n.id).join(', ')}`,
    metadata: { isolatedNodeIds: isolatedNodes.map(n => n.id) }
  });
}
```

