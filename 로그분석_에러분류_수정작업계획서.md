# 로그 분석 기반 에러 분류 및 수정 작업 계획서

## 문서 개요

본 문서는 `system_logs_2025-11-02.json` 로그 파일을 분석하여 발견된 이슈를 분류하고 수정 작업 계획을 수립합니다.

**분석 일시**: 2025년 11월 4일  
**로그 파일**: system_logs_2025-11-02.json  
**총 로그 수**: 1,000개  
**분석 범위**: 2025-11-02 기준

---

## 요구사항 및 현황 분석

### 로그 현황
- **로그 레벨**: 모든 로그가 "info" 레벨
- **HTTP 상태 코드**: 200 (497개), null (503개 - 요청 로그)
- **주요 엔드포인트**: `/api/azure/services/status` (971회 호출)
- **명시적 에러**: 0개 (errorType, errorMessage 필드 모두 null)

### 발견된 이슈
1. **성능 이슈**: 느린 응답 시간 (> 1초) - 9건
2. **Null 응답**: 요청 로그의 responseData가 null인 경우 - 503건
3. **Databricks 스키마 조회 성능**: 매우 느린 응답 시간 (22초 이상)

---

## 핵심 개선 포인트 도출

### 1순위: 성능 이슈 (크리티컬)
- **Databricks 스키마 조회**: 22,253ms (22초) - 매우 느림
- **Databricks Unity Catalog 조회**: 22,252ms (22초) - 매우 느림
- **Databricks Delta Table 조회**: 2,255ms ~ 1,520ms - 느림
- **Azure Services Status**: 1,599ms - 개선 필요

### 2순위: 로깅 개선
- **요청 로그의 Null 응답**: 요청 로그에 responseData가 null인 경우가 많음
- **에러 로깅 부재**: 명시적 에러가 로그에 기록되지 않음
- **성능 모니터링**: 느린 요청에 대한 경고 로그 부재

### 3순위: 최적화
- **반복 호출**: `/api/azure/services/status` 엔드포인트가 971회 호출 (캐싱 필요)
- **응답 크기**: 대용량 응답에 대한 모니터링 필요

---

## 솔루션 시나리오 제안

### Phase 1: 성능 이슈 해결 (1주)

#### 1단계: Databricks 스키마 조회 성능 개선
**목표**: Databricks 스키마 조회 응답 시간을 22초에서 2초 이하로 단축

**현황 분석**:
- `/api/azure/databricks/schema`: 22,253ms
- `/api/azure/databricks/unity-catalog`: 22,252ms
- 매우 느린 응답 시간으로 인한 사용자 경험 저하

**개선 방안**:
1. 스키마 조회 결과 캐싱 구현 (Redis 또는 메모리 캐시)
2. 캐시 만료 시간 설정 (1시간)
3. 스키마 조회 API에 타임아웃 설정 (최대 5초)
4. 배치 조회로 변경 (한 번에 여러 스키마 조회)
5. 인덱스 최적화 (Databricks 쿼리 최적화)

**예상 파일**:
- `server/services/azure-databricks.ts`
- `server/routes.ts` (Databricks 엔드포인트)
- `server/services/cache-service.ts` (신규 또는 기존)

**기대 효과**: 응답 시간 22초 → 2초 이하 (90% 이상 개선)

---

#### 2단계: Databricks Delta Table 조회 성능 개선
**목표**: Delta Table 조회 응답 시간을 2초에서 500ms 이하로 단축

**현황 분석**:
- `/api/azure/databricks/delta-table/nh_ai/bronze/e900s_raw`: 2,255ms
- `/api/azure/databricks/delta-table/nh_ai/bronze/kri1_raw`: 1,520ms

**개선 방안**:
1. Delta Table 메타데이터 캐싱
2. 테이블 목록 조회 최적화 (LIMIT 추가)
3. 병렬 조회 구현 (여러 테이블 동시 조회)
4. 쿼리 최적화 (불필요한 컬럼 조회 제거)

**예상 파일**:
- `server/services/azure-databricks.ts`
- `server/routes.ts` (Delta Table 엔드포인트)

**기대 효과**: 응답 시간 2초 → 500ms 이하 (75% 이상 개선)

---

#### 3단계: Azure Services Status 응답 시간 개선
**목표**: 서비스 상태 조회 응답 시간을 1.6초에서 500ms 이하로 단축

**현황 분석**:
- `/api/azure/services/status`: 971회 호출 (매우 빈번)
- 평균 응답 시간: 1599ms (최대)
- 캐싱 없이 매번 실제 연결 테스트 수행

**개선 방안**:
1. 서비스 상태 캐싱 구현 (5분 간격 갱신)
2. 백그라운드 상태 체크 (주기적 갱신)
3. 병렬 연결 테스트 (모든 서비스 동시 테스트)
4. 연결 타임아웃 설정 (각 서비스별 2초)

**예상 파일**:
- `server/routes.ts` (Azure Services Status 엔드포인트)
- `server/services/azure-config.ts`

**기대 효과**: 응답 시간 1.6초 → 500ms 이하 (70% 이상 개선), 캐시 히트 시 100ms 이하

---

### Phase 2: 로깅 개선 (3일)

#### 4단계: 에러 로깅 강화
**목표**: 모든 에러를 명확하게 로그에 기록

**현황 분석**:
- 로그 파일에 명시적 에러가 없음 (errorType, errorMessage 모두 null)
- 실제 에러가 발생해도 로그에 기록되지 않을 가능성

**개선 방안**:
1. 에러 핸들링 미들웨어 개선 (모든 에러를 로그에 기록)
2. 에러 로그 레벨 설정 (error, warn 레벨 사용)
3. 에러 스택 트레이스 기록
4. 에러 발생 시 상세 정보 기록 (요청 데이터, 응답 데이터, 사용자 정보)

**예상 파일**:
- `server/index.ts` (에러 핸들링 미들웨어)
- `server/utils/error-logger.ts` (에러 로깅 유틸리티)

**기대 효과**: 에러 추적 가능성 향상, 디버깅 시간 단축

---

#### 5단계: 성능 모니터링 로그 추가
**목표**: 느린 요청에 대한 경고 로그 추가

**현황 분석**:
- 느린 요청이 발생해도 별도 경고가 없음
- 성능 임계값 설정 부재

**개선 방안**:
1. 응답 시간 임계값 설정 (1초, 5초, 10초)
2. 느린 요청에 대한 경고 로그 추가
3. 성능 모니터링 대시보드 연동
4. 주기적 성능 리포트 생성

**예상 파일**:
- `server/utils/performance-logger.ts` (신규)
- `server/routes.ts` (모든 엔드포인트에 성능 로깅 추가)

**기대 효과**: 성능 문제 조기 발견, 사용자 경험 개선

---

#### 6단계: 요청 로그 개선
**목표**: 요청 로그의 불필요한 null 필드 제거 또는 개선

**현황 분석**:
- 요청 로그 (logType: "request")의 responseData가 null
- 이는 정상이지만, 로그 구조 개선 가능

**개선 방안**:
1. 요청/응답 로그 분리 명확화
2. 요청 로그에는 requestData만 기록
3. 응답 로그에는 responseData만 기록
4. 로그 크기 최적화

**예상 파일**:
- `server/utils/request-logger.ts`
- 로깅 미들웨어

**기대 효과**: 로그 가독성 향상, 저장 공간 절약

---

### Phase 3: 최적화 및 모니터링 (2일)

#### 7단계: API 호출 최적화
**목표**: 불필요한 반복 호출 최소화

**현황 분석**:
- `/api/azure/services/status`: 971회 호출 (총 1,000개 로그 중)
- 매우 빈번한 호출로 인한 서버 부하

**개선 방안**:
1. 프론트엔드에서 폴링 간격 조정 (30초 → 60초)
2. 서버 측 캐싱 강화
3. WebSocket을 통한 실시간 상태 업데이트
4. 사용자가 페이지를 떠났을 때 폴링 중지

**예상 파일**:
- `client/src/pages/dashboard.tsx` (서비스 상태 조회)
- `server/services/websocket.ts` (WebSocket 상태 브로드캐스트)

**기대 효과**: 서버 부하 감소, 네트워크 트래픽 감소

---

#### 8단계: 응답 크기 모니터링
**목표**: 대용량 응답에 대한 모니터링 및 최적화

**현황 분석**:
- 현재 대용량 응답 (> 100KB) 없음
- 하지만 모니터링 필요

**개선 방안**:
1. 응답 크기 임계값 설정 (100KB, 1MB)
2. 대용량 응답에 대한 경고 로그
3. 페이징 구현 (큰 데이터셋)
4. 응답 압축 (gzip)

**예상 파일**:
- `server/utils/response-logger.ts` (신규)
- `server/index.ts` (응답 압축 미들웨어)

**기대 효과**: 네트워크 트래픽 감소, 응답 시간 개선

---

## 기대 효과 설명

### 정량적 효과
1. **성능 개선**: 
   - Databricks 스키마 조회: 22초 → 2초 (90% 개선)
   - Delta Table 조회: 2초 → 500ms (75% 개선)
   - 서비스 상태 조회: 1.6초 → 500ms (70% 개선, 캐시 히트 시 100ms)

2. **서버 부하 감소**:
   - 서비스 상태 조회 호출: 971회 → 예상 300회 (70% 감소)
   - 캐싱으로 인한 실제 연결 테스트 감소

3. **로그 품질 향상**:
   - 에러 추적 가능성: 0% → 100%
   - 성능 문제 조기 발견: 즉시 알림

### 정성적 효과
1. **사용자 경험**: 페이지 로딩 시간 단축, 반응성 향상
2. **운영 효율성**: 문제 발견 및 해결 시간 단축
3. **시스템 안정성**: 성능 모니터링으로 예방적 관리 가능

---

## 우선순위 및 일정

### Phase 1: 성능 이슈 해결 (1주)
- 1단계: Databricks 스키마 조회 성능 개선 (3일)
- 2단계: Databricks Delta Table 조회 성능 개선 (2일)
- 3단계: Azure Services Status 응답 시간 개선 (2일)

### Phase 2: 로깅 개선 (3일)
- 4단계: 에러 로깅 강화 (1일)
- 5단계: 성능 모니터링 로그 추가 (1일)
- 6단계: 요청 로그 개선 (1일)

### Phase 3: 최적화 및 모니터링 (2일)
- 7단계: API 호출 최적화 (1일)
- 8단계: 응답 크기 모니터링 (1일)

---

## 추가 개선 사항 (참고)

### 발견된 패턴
1. **로그 레벨**: 모든 로그가 "info" 레벨 - 경고, 에러 레벨 활용 필요
2. **HTTP 상태 코드**: 200만 존재 - 4xx, 5xx 에러 로그 부재
3. **에러 필드**: errorType, errorMessage 모두 null - 에러 발생 시 기록 필요

### 권장 사항
1. **로깅 정책**: 에러 발생 시 반드시 error 레벨로 기록
2. **성능 임계값**: 응답 시간 임계값 설정 및 모니터링
3. **캐싱 전략**: 자주 조회되는 데이터에 대한 캐싱 구현
4. **알림 시스템**: 성능 문제 발생 시 알림 전송

---

## 결론

로그 분석 결과, 명시적 에러는 없었으나 성능 이슈와 로깅 개선 필요성이 발견되었습니다. 특히 Databricks 스키마 조회 성능이 매우 느려 (22초) 우선적으로 개선해야 합니다.

Phase 1의 성능 이슈 해결을 최우선으로 진행하고, 이후 Phase 2, Phase 3를 순차적으로 진행하는 것을 권장합니다.

**이 방향에 대해 어떻게 생각하시나요?**

